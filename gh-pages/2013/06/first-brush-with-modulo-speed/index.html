<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Primary Unit mirror on GitHub – First brush with modulo speed</title>

  <!-- Load my combined stylesheet -->
  <link rel="stylesheet" href="/resources/all.min.css">


  <link rel="license" href="https://creativecommons.org/licenses/by/4.0/">

  <link rel="alternate" type="application/rss+xml" title="RSS feed for Primary Unit" href="/rss">
  <link rel="alternate" type="application/json" title="JSON feed for Primary Unit" href="/feed.json">

  <!-- Apple pinned sites icon, Apple touch icon, Favicon -->
  <link rel="mask-icon" href="/resources/favicon.svg" color="#1369BF">
  <link rel="apple-touch-icon-precomposed" href="/resources/favicon.png">
  <link rel="icon" href="/resources/favicon.ico">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="A mirror of https://www.robjwells.com hosted on GitHub">
</head>

<body>

<div class="wrapper">

<header class="site-header">

  <div class="site-title-container mute-links">
    <h1 class="site-title"><a href="https://robjwells.github.io">Primary Unit mirror on GitHub</a></h1>
    <p class="site-byline"><i>by</i> Rob Wells</p>
  </div>

  <div class="site-menu-container">

    <nav id="site-nav">
      <ul class="site-links mute-links">
        <li><a href="/about/">About</a></li>
        <li><a href="/archives/">Archives</a></li>
        <li><a href="/feed.json">JSON&nbsp;feed</a></li>
        <li><a href="/rss">RSS&nbsp;feed</a></li>
      </ul>
    </nav>

    <label for="search-field" class="site-search-label">
      Site search
    </label>
    <form id="site-search" class="site-search" method="get" action="https://duckduckgo.com/">
      <input name="q" type="text" id="search-field" class="search-field" placeholder="via DuckDuckGo">
      <input name="sites" value="https://robjwells.github.io" hidden>
      <button type="submit" class="search-button">Search</button>
    </form>

  </div> <!-- .site-menu-container -->

</header> <!-- .site-header -->

<main role="main">

  <article>
    <header>
      <h2 class="mute-links"><a href="https://robjwells.github.io/2013/06/first-brush-with-modulo-speed/">First brush with modulo speed</a></h2>
      <p><time datetime="2013-06-29T12:05">Saturday, June 29 2013</time></p>
    </header>
    <p>I had read that the modulo operator (remainder after integer division) was slow but had never had a chance to try to break it myself, until a couple of days ago. I was distracted from my <a href="http://getpython3.com/diveintopython3/">current project</a> by <a href="http://projecteuler.net">Project Euler</a>, after searching for a way to test and improve my programming and maths skills.</p>
<p>Project Euler is a collection of problems designed to exercise those skills and its first, simplest task is to add up the multiples of 3 and 5 below 1,000, which I first solved with a fairly typical “brute-force” approach:</p>
<pre><code>sum = 0
for x in range(1, 1000):
    if x % 3 == 0 or x % 5 == 0:
        sum += x</code></pre>


<p>This iterates over the numbers 1 through 999, checking to see if there’s a remainder after dividing by 3 or 5. After finishing, I read on the problem’s forum thread of a way of achieving the result with a little more maths and without using the modulo.</p>
<p>I tried it out for fun and to be honest wasn’t impressed — when timed with the Unix <code>time</code> command both methods took around 0.025 seconds.</p>
<p>So I decided to kick the limit up a bit, from 999 to 999,999,999.</p>
<p>The modulo method took 4 minutes and 24.506 seconds (264.506s) while the more mathematical approach held steady at 0.026 seconds. Over 10,000 times as fast. Yes, I double-checked the results.</p>
<p>The modulo code was similar to that above while the other method was written like so:</p>
<pre><code>def sum_series(multiple, top_limit):
    mult_max = top_limit // multiple
    return multiple * (mult_max * (mult_max + 1)) / 2

print(sum_series(3, 999)
        + sum_series(5, 999)
        - sum_series(15, 999))</code></pre>


<p>The <code>sum_series</code> function works out how many multiples of a given number there are between 0 and <code>top_limit</code> and adds them up.</p>
<p>But you can avoid iterating over them because of the interesting fact that the sum of all <a href="http://en.wikipedia.org/wiki/Natural_numbers">natural numbers</a> through <em>x</em> is <em>x × (x + 1) ÷ 2</em>. It took me a while of head-scratching before I <a href="http://mathandmultimedia.com/2010/09/15/sum-first-n-positive-integers/">read an explanation</a> (two, actually) that made sense.</p>
<p>The function does that for the <em>number</em> of multiples, and then multiplies the result by the number in question to actually <em>make</em> them multiples. For example, 1 + 2 + 3 through 333 become 3 + 6 + 9 through 999.</p>
<p>Repeat with 5, then subtract the results for 15 (to remove the double-counted multiples of both 3 and 5) and you’re done.</p>
  </article>

</main>

<footer class="site-footer">
  <small class="mute-links">
    This work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
    Creative Commons Attribution 4.0 International License</a>.
  </small>
</footer> <!-- .site-footer -->

</div> <!-- .wrapper -->

</body>

</html>