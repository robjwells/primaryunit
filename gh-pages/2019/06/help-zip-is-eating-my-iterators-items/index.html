<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Primary Unit mirror on GitHub – Help, zip is eating my iterator’s items</title>

  <!-- Load my combined stylesheet -->
  <link rel="stylesheet" href="/resources/all.min.css">

  <!-- Load my combined JavaScript -->
  <script src="/resources/all.min.js" async></script>

  <link rel="license" href="https://creativecommons.org/licenses/by/4.0/">

  <link rel="alternate" type="application/rss+xml" title="RSS feed for Primary Unit" href="/rss">
  <link rel="alternate" type="application/json" title="JSON feed for Primary Unit" href="/feed.json">

  <!-- Apple pinned sites icon, Apple touch icon, Favicon -->
  <link rel="mask-icon" href="/resources/favicon.svg" color="#1369BF">
  <link rel="apple-touch-icon-precomposed" href="/resources/favicon.png">
  <link rel="icon" href="/resources/favicon.ico">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="A mirror of https://www.robjwells.com hosted on GitHub">
</head>

<body>

<div class="wrapper">

<header class="site-header">

  <div class="site-title-container mute-links">
    <h1 class="site-title"><a href="https://robjwells.github.io">Primary Unit mirror on GitHub</a></h1>
    <p class="site-byline"><i>by</i> Rob Wells</p>
  </div>

  <div class="site-menu-container">

    <nav id="site-nav">
      <ul class="site-links mute-links">
        <li><a href="/about/">About</a></li>
        <li><a href="/archives/">Archives</a></li>
        <li><a href="/feed.json">JSON&nbsp;feed</a></li>
        <li><a href="/rss">RSS&nbsp;feed</a></li>
      </ul>
    </nav>

    <label for="search-field" class="site-search-label">
      Site search
    </label>
    <form id="site-search" class="site-search" method="get" action="https://duckduckgo.com/">
      <input name="q" type="text" id="search-field" class="search-field" placeholder="via DuckDuckGo">
      <input name="sites" value="https://robjwells.github.io" hidden>
      <button type="submit" class="search-button">Search</button>
    </form>

  </div> <!-- .site-menu-container -->

</header> <!-- .site-header -->

<main role="main">

  <article>
    <header>
      <h2 class="mute-links"><a href="https://robjwells.github.io/2019/06/help-zip-is-eating-my-iterators-items/">Help, zip is eating my iterator’s items</a></h2>
      <p><time datetime="2019-06-18T00:23">Tuesday, June 18 2019</time></p>
    </header>
    <p>Python’s <a href="https://docs.python.org/3.7/library/functions.html#zip"><code>zip</code></a> function, which knits together two iterables, is indispensable for me. It works like this:</p>
<div class="syntax"><pre><span></span><span class="n">list_one</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">list_two</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list_one</span><span class="p">,</span> <span class="n">list_two</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
<span class="c1"># (1, &#39;a&#39;)</span>
<span class="c1"># (2, &#39;b&#39;)</span>
<span class="c1"># (3, &#39;c&#39;)</span>
</pre></div>


<p>If the two iterables differ in length, zip halts after the shortest is exhausted. If we add an additional element to one of the lists above, we get the same results:</p>
<div class="syntax"><pre><span></span><span class="n">list_one</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">list_two</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">]</span>  <span class="c1"># Note extra item, &quot;d&quot;</span>
<span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list_one</span><span class="p">,</span> <span class="n">list_two</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
<span class="c1"># (1, &#39;a&#39;)</span>
<span class="c1"># (2, &#39;b&#39;)</span>
<span class="c1"># (3, &#39;c&#39;)</span>
</pre></div>


<p>But the actual mechanics of this surprised me. Today I was working on the “chunked” problem from <a href="https://www.pythonmorsels.com">Python Morsels</a> (which is great and you should totally try out if you write Python), and was left scratching my head after elements of my iterable started disappearing.</p>
<p>The basic problem for chunked is this: given some iterable, return its elements in <code>count</code>-length lists. <a href="https://treyhunner.com">Trey</a> likes you to think in terms of “any iterable” so you can’t depend on list-like behaviour, such as being able to index into the iterable or check its length without consuming it.</p>
<p>It’s safer to assume you get one traversal. So, my solution starts like this, creating an <a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">iterator from the iterable</a>.</p>
<div class="syntax"><pre><span></span><span class="k">def</span> <span class="nf">chunked</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>


<p>Then (eliding the scaffolding) I build up a new <code>count</code>-length chunk using <code>zip</code> in a comprehension:</p>
<div class="syntax"><pre><span></span><span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">))]</span>
</pre></div>


<p>Here I use the “earliest finish” behaviour of <code>zip</code> paired with <code>range</code> — the amount of numbers in the range (<code>count</code>-many of them) determines how many items I fetch from the iterator.</p>
<p>Let’s give this a try, using your imagination to flesh out the rest of <code>chunked</code>:</p>
<div class="syntax"><pre><span></span><span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunked</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">count</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
<span class="c1"># [0, 1, 2, 3]</span>
<span class="c1"># [5, 6, 7, 8]</span>
</pre></div>


<p>Er, hm. Not what I was expecting, which was:</p>
<div class="syntax"><pre><span></span><span class="c1"># [0, 1, 2, 3]</span>
<span class="c1"># [4, 5, 6, 7]</span>
<span class="c1"># [8, 9]</span>
</pre></div>


<p>Somehow, the program is consuming an extra item from <code>iterator</code> each time I create a chunk. But that list comprehension is the only place where I touch <code>iterator</code>. What gives?</p>
<p>Well, how does <code>zip</code> know when to terminate? If you take a look <a href="https://docs.python.org/3.7/library/functions.html#zip">in the documentation</a>, you’ll see a handy code sample that is “equivalent to” the implementation of <code>zip</code>. There we see that <code>zip</code> builds up a list of results by taking an item from each of the given iterables, but if any of those iterables are finished, it just returns — and discards the result list!</p>
<p>So what happens with <code>zip(longer, shorter)</code> is that it takes from <code>longer</code>, stashes the item, discovers <code>shorter</code> is exhausted, and discards the item from <code>longer</code>. And that’s what happens to the missing numbers in the example above.</p>
<p>This situation arises because I’m zipping the same iterable repeatedly, until it’s empty, and because the iterator is the first argument to <code>zip</code>. This small change works fine:</p>
<div class="syntax"><pre><span></span><span class="c1"># Old, broken</span>
<span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">))]</span>
<span class="c1"># New, fixed</span>
<span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">),</span> <span class="n">iterator</span><span class="p">)]</span>
</pre></div>


<p>In the new version, <code>zip</code> discovers that the iterator over the range is exhausted <em>first</em>, before it takes an item from <code>iterator</code>, so no items are ever discarded.</p>
<p>So, is this OK? Really, really not! This is <em>super</em>-fragile. It’s not obvious that switching the arguments will break the code. And really it just <em>looks</em> wrong, because surely the ignored tuple element (assigned to the underscore) should come after the item that we care about?</p>
<p>Thankfully, the <a href="https://docs.python.org/3.7/library/itertools.html#module-itertools"><code>itertools</code></a> module has what we need (as always!). The reason I originally used the list comprehension-zip-range combo is because you can’t slice every iterable. For example:</p>
<div class="syntax"><pre><span></span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))[:</span><span class="mi">4</span><span class="p">]</span>
<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># TypeError                                 Traceback (most recent call last)</span>
<span class="c1"># &lt;ipython-input-2-17f2a627cc7c&gt; in &lt;module&gt;</span>
<span class="c1"># ----&gt; 1 (x**2 for x in range(10))[:4]</span>
<span class="c1">#</span>
<span class="c1"># TypeError: &#39;generator&#39; object is not subscriptable</span>
</pre></div>


<p>But you can with <a href="https://docs.python.org/3.7/library/itertools.html#itertools.islice"><code>islice</code></a>:</p>
<div class="syntax"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># [0, 1, 4, 9]</span>
</pre></div>


<p>And this works great with iterators where you care about the current state:</p>
<div class="syntax"><pre><span></span><span class="n">to_10_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">to_10_sq</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># [0, 1, 4, 9]</span>
<span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">to_10_sq</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># [16, 25, 36, 49]</span>
<span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">to_10_sq</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># [64, 81]</span>
</pre></div>


<p>Which leads us to the most straightforward way of building up those chunks.</p>
<div class="syntax"><pre><span></span><span class="n">chunk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
</pre></div>


<p>(The chunks have to be “concrete” sequences as the problem requires some length-checking for one of the bonus parts, hence the <code>list</code> call.)</p>
<p>Thanks for reading. If I have some key messages, they’re these:</p>
<ul>
<li>Python is lovely, but it’s not magic!</li>
<li><a href="https://docs.python.org/3.7/library/itertools.html#module-itertools"><code>itertools</code></a> might have solved your iteration problem already.</li>
<li>Check out <a href="https://www.pythonmorsels.com">Python Morsels</a>. The problems are short, fun, and a nice way to improve your Python skills.</li>
</ul>
  </article>

</main>

<footer class="site-footer">
  <small class="mute-links">
    This work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
    Creative Commons Attribution 4.0 International License</a>.
  </small>
</footer> <!-- .site-footer -->

</div> <!-- .wrapper -->

</body>

</html>